import { InvalidAccountStatusError } from "@domain/errors"
import { checkedToAccountLevel } from "@domain/accounts"
import { AccountsRepository, UsersRepository } from "@services/mongoose"
import { IdentityRepository } from "@services/kratos"
import ErpNext from "@services/frappe/ErpNext"
import { updateAccountLevel } from "./update-account-level"

type BusinessUpgradeRequestInput = {
  accountId: AccountId
  level: number
  businessName: string
  businessType: string
  businessAddress: string
  businessPhone: string
  additionalInfo?: string
}

/**
 * Request an account level upgrade with business information.
 *
 * Creates a support Issue in ERPNext with structured business data.
 *
 * Behavior by level:
 * - Level 2 (Pro): Creates Issue AND auto-upgrades account immediately
 * - Level 3 (Merchant): Creates Issue only, requires manual admin approval
 *
 * @param input - Business upgrade request data
 * @returns Success or an error
 */
export const businessAccountUpgradeRequest = async (
  input: BusinessUpgradeRequestInput
): Promise<true | ApplicationError> => {
  const { accountId, level, businessName, businessType, businessAddress, businessPhone, additionalInfo } = input

  const accountsRepo = AccountsRepository()
  const usersRepo = UsersRepository()

  // Get account details
  const account = await accountsRepo.findById(accountId)
  if (account instanceof Error) return account

  // Validate requested level
  const checkedLevel = checkedToAccountLevel(level)
  if (checkedLevel instanceof Error) return checkedLevel

  // Prevent downgrade requests
  if (checkedLevel < account.level) {
    return new InvalidAccountStatusError("Cannot request account level downgrade")
  }

  // Short-circuit if no change needed
  if (checkedLevel === account.level) {
    return new InvalidAccountStatusError("Account is already at requested level")
  }

  // Get user details
  const user = await usersRepo.findById(account.kratosUserId)
  if (user instanceof Error) return user

  // Get identity details (for email)
  const identity = await IdentityRepository().getIdentity(account.kratosUserId)
  if (identity instanceof Error) return identity

  // Format Issue description with structured data for parsing
  const description = `
Account Upgrade Request - ${levelToName(checkedLevel)}

=== USER INFORMATION ===
Username: ${account.username || "N/A"}
Account ID: ${account.id}
User ID: ${account.kratosUserId}
Phone: ${user.phone || "N/A"}
Email: ${identity.email || "N/A"}
Current Level: ${account.level} (${levelToName(account.level)})
Requested Level: ${checkedLevel} (${levelToName(checkedLevel)})

=== BUSINESS INFORMATION ===
Business Name: ${businessName}
Business Type: ${businessType}
Business Address: ${businessAddress}
Business Phone: ${businessPhone}

${additionalInfo ? `=== ADDITIONAL INFORMATION ===\n${additionalInfo}` : ""}

---
Created: ${new Date().toISOString()}
Auto-generated by Flash Account Upgrade System
`.trim()

  // Create Issue in ERPNext
  const issueResult = await ErpNext.createSupportIssue({
    subject: `Account Upgrade: ${account.username || account.id} → Level ${checkedLevel}`,
    description,
    priority: checkedLevel === 3 ? "High" : "Medium",
    issueType: "Account Upgrade Request",
  })

  if (issueResult instanceof Error) return issueResult

  // If level is 2 (Pro), auto-upgrade immediately
  if (checkedLevel === 2) {
    const upgradeResult = await updateAccountLevel({
      id: accountId,
      level: checkedLevel,
    })
    if (upgradeResult instanceof Error) return upgradeResult
  }

  // Level 3 (Merchant) requires manual approval - just ticket created
  return true
}

/**
 * Check if user has pending upgrade requests
 */
export const hasPendingUpgradeRequest = async (
  username: Username
): Promise<{ hasPending: boolean; requestedLevel: AccountLevel | null } | ApplicationError> => {
  const openIssues = await ErpNext.getOpenIssuesByUsername(username as string)

  if (openIssues instanceof Error) return openIssues

  // Parse the issues to find requested level from subject
  if (openIssues.length > 0) {
    // Try to extract level from first open issue subject
    // Format: "Account Upgrade: username → Level X"
    const firstIssue = openIssues[0]
    const levelMatch = firstIssue.match(/Level (\d+)/)
    const requestedLevel = levelMatch ? parseInt(levelMatch[1]) : null

    return {
      hasPending: true,
      requestedLevel: requestedLevel as AccountLevel | null,
    }
  }

  return {
    hasPending: false,
    requestedLevel: null,
  }
}

// Helper to convert level number to name
function levelToName(level: number): string {
  const names: Record<number, string> = {
    0: "Standard",
    1: "Verified",
    2: "Pro",
    3: "Merchant",
  }
  return names[level] || "Unknown"
}
